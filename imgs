#!/usr/bin/env node

const args = require("minimist")(process.argv.slice(2));
const http = require("http");
const url = require("url");
const path = require("path");
const fs = require("fs");
const imageSize = require("image-size");
const Dir = require("./Dir");
const isImage = require("./isImage");
let password;

function link(str, query)
{
    if (query) {
        if (str.indexOf("?") !== -1) {
            str += "&" + query;
        } else {
            str += "?" + query;
        }
    }
    return str;
}

// Seeded random number generator for consistent shuffling
function seededRandom(seed)
{
    return function() {
        seed = (seed * 1103515245 + 12345) & 0x7fffffff;
        return seed / 0x7fffffff;
    };
}

function shuffleWithSeed(array, seed)
{
    const result = [...array];
    const random = seededRandom(seed);
    for (let i = result.length - 1; i > 0; i--) {
        const j = Math.floor(random() * (i + 1));
        [result[i], result[j]] = [result[j], result[i]];
    }
    return result;
}

function parseCookies(cookieHeader)
{
    const cookies = {};
    if (!cookieHeader) return cookies;
    cookieHeader.split(';').forEach(cookie => {
        const parts = cookie.split('=');
        const name = parts[0].trim();
        const value = parts.slice(1).join('=').trim();
        if (name) cookies[name] = value;
    });
    return cookies;
}

function loginHTML(response)
{
    const html = `
<html>
  <head>
    <title>Login</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
body {
    font-family: sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    background: #f0f0f0;
}
form {
    background: white;
    padding: 2rem;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}
input[type="text"] {
    font-size: 1rem;
    padding: 0.5rem;
    margin-right: 0.5rem;
    border: 1px solid #ccc;
    border-radius: 4px;
}
button {
    font-size: 1rem;
    padding: 0.5rem 1rem;
    background: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}
button:hover {
    background: #0056b3;
}
    </style>
  </head>
  <body>
    <form id="loginForm">
      <input type="text" name="password" id="password" placeholder="Password" autofocus>
      <button type="submit">Login</button>
    </form>
    <script>
document.getElementById('loginForm').addEventListener('submit', function(e) {
    e.preventDefault();
    var pw = document.getElementById('password').value;
    sessionStorage.setItem('auth', pw);
    document.cookie = 'auth=' + encodeURIComponent(pw) + '; path=/';
    window.location.href = '/';
});
document.getElementById('password').focus();
    </script>
  </body>
</html>`;
    response.writeHead(200, {"Content-Type": "text/html"});
    response.write(html);
    response.end();
}

const authCheckScript = `
<script>
(function() {
    var stored = sessionStorage.getItem('auth');
    if (!stored) {
        document.cookie = 'auth=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT';
        window.location.href = '/__login';
    }
})();
</script>`;


if (!args.dir) {
    console.error("No --dir");
    process.exit(1);
}

if (args.dir[args.dir.length - 1] !== "/") {
    args.dir += "/";
}
if (!args.port) {
    console.error("No --port");
    process.exit(1);
}

password = args.password ? String(args.password) : undefined;

// Watch source files for changes - exit so systemd can restart
const sourceFiles = [
    path.join(__dirname, 'imgs'),
    path.join(__dirname, 'Dir.js'),
    path.join(__dirname, 'isImage.js')
];

sourceFiles.forEach(file => {
    fs.watch(file, (event, filename) => {
        console.log(`Source file changed: ${file} (${event})`);
        process.exit(0);
    });
});

// Watch served directory recursively for changes (Linux Node 18.17+)
// On older Node.js, recursive option is silently ignored on Linux
// Since Dir reads fresh each request, there's no cache - this is just informational
if (parseInt(process.versions.node.split('.')[0], 10) >= 18) {
    try {
        fs.watch(args.dir, { recursive: true }, (event, filename) => {
            if (filename) {
                console.log(`Content changed: ${filename} (${event})`);
            }
        });
    } catch (err) {
        console.error('Could not set up recursive watch on served directory:', err.message);
    }
}

function linksHTML(response, filePath)
{
    fs.readFile(filePath, "utf-8", (err, data) => {
        if (err) {
            response.writeHead(404, {"Content-Type": "text/plain"});
            response.write(err + "\n");
            response.end();
            return;
        }

        const links = data.split("\n").filter(x => x.startsWith("http")).map(x => {
            return `    <p><a href="${link(x)}">${x}</a></p>`;
        }).join("\n");

        response.writeHead(200);
        const payload = `<html>
  <head>
${password ? authCheckScript : ''}
  </head>
  <body>
${links}
  </body>`;

        response.write(payload);
        response.end();
    });
}

function imageHTML(response, filepath, dir, cookies, setCookieHeader)
{
    const tripleView = cookies.tripleview !== '0';
    const toggleLink = tripleView ? link(filepath, 'view1') : link(filepath, 'view3');
    const toggleText = tripleView ? '1' : '3';

    const shuffleSeed = cookies.shuffle ? parseInt(cookies.shuffle, 10) : null;
    const shuffleLinks = shuffleSeed
        ? `<a href="${link(filepath, 'unshuffle')}">Unshuffle</a> | <a href="${link(filepath, 'shuffle')}">Reshuffle</a>`
        : `<a href="${link(filepath, 'shuffle')}">Shuffle</a>`;

    // Get prev/next images for triple view
    const images = shuffleSeed ? shuffleWithSeed(dir.images, shuffleSeed) : dir.images;
    const currentIdx = images.indexOf(path.basename(filepath));

    let prevImg = null, nextImg = null;
    if (currentIdx !== -1 && images.length > 1) {
        const prevIdx = currentIdx === 0 ? images.length - 1 : currentIdx - 1;
        const nextIdx = currentIdx === images.length - 1 ? 0 : currentIdx + 1;
        prevImg = path.join(dir.relative, images[prevIdx]);
        nextImg = path.join(dir.relative, images[nextIdx]);
    }

    const imgHeight = tripleView ? 'calc(33.33vh - 20px)' : 'calc(100vh - 60px)';

    let imagesHtml;
    if (tripleView && prevImg && nextImg) {
        imagesHtml = `
       <a href="${link(filepath, 'prev')}"><div class="imgbox">
         <img class="center-fit" src="${link(prevImg, 'data')}"/>
       </div></a>
       <a href="${link(filepath, 'next')}"><div class="imgbox current">
         <img class="center-fit" src="${link(filepath, 'data')}"/>
       </div></a>
       <a href="${link(filepath, 'next')}"><div class="imgbox">
         <img class="center-fit" src="${link(nextImg, 'data')}"/>
       </div></a>`;
    } else {
        imagesHtml = `
       <a href="${link(filepath, 'next')}"><div class="imgbox">
         <img class="center-fit" src="${link(filepath, 'data')}"/>
       </div></a>`;
    }

    const str = `
<html>
  <head title="${filepath}">
${password ? authCheckScript : ''}
    <style>
* {
    font-size: 25px;
    margin: 0;
    padding: 0;
}
html, body {
    height: 100%;
}
.imgbox {
    display: flex;
    justify-content: center;
    align-items: center;
    height: ${imgHeight};
}
.center-fit {
    width: 100%;
    height: 100%;
    object-fit: contain;
}
    </style>
  </head>
  <body>
     <p>
&nbsp;
     </p>
     <p>
       &nbsp;&nbsp;&nbsp;&nbsp;<a href="${link(filepath, 'prev')}">Previous</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="${link(filepath, 'next')}">Next</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="${link(path.dirname(filepath))}">Dir</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="${toggleLink}">${toggleText}</a>&nbsp;&nbsp;&nbsp;&nbsp;${shuffleLinks}
     </p>
${imagesHtml}
  </body>
</html>`;

    const headers = {"Content-Type": "text/html"};
    if (setCookieHeader) {
        headers["Set-Cookie"] = setCookieHeader;
    }
    response.writeHead(200, headers);
    response.write(str);
    response.end();
}

function dirHTML(url, response, dir, query, cookies, setCookieHeader)
{
    let str = `
<html>
  <head title="${dir.relative}">
${password ? authCheckScript : ''}
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
* {
  box-sizing: border-box;
}

.grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
  gap: 10px;
  padding: 10px;
}

.grid a {
  display: block;
}

.grid img {
  width: 100%;
  height: 100px;
  object-fit: cover;
}
    </style>
  </head>
  <body>
`;
    if (dir.bookmarks) {
        str += `<p><a href="${link(path.join(dir.relative, 'bookmark.url'))}">Bookmarks</a></p>\n`;
    }

    let images = dir.images;
    const shuffleSeed = cookies.shuffle ? parseInt(cookies.shuffle, 10) : null;

    if (shuffleSeed) {
        images = shuffleWithSeed(dir.images, shuffleSeed);
        if (images.length) {
            str += `<p><a href="${link(dir.relative, 'unshuffle')}">Unshuffle</a> | <a href="${link(dir.relative, 'shuffle')}">Reshuffle</a></p>\n`;
        }
    } else {
        if (images.length) {
            str += `<p><a href="${link(dir.relative, 'shuffle')}">Shuffle</a></p>\n`;
        }
    }

    dir.dirs.forEach(dirpath => {
        str += `<p><a href="${link(path.join(dir.relative, dirpath))}">${dirpath}</a></p>
`;
    });
    if (images.length) {
        str += `<div class="grid">\n`;
        images.forEach(img => {
            str += `<a href="${link(path.join(dir.relative, img))}"><img src="${link(path.join(dir.relative, img), 'data')}"></a>\n`;
        });
        str += `</div>\n`;
    }
    str += "</body>\n</html>";

    const headers = {"Content-Type": "text/html"};
    if (setCookieHeader) {
        headers["Set-Cookie"] = setCookieHeader;
    }
    response.writeHead(200, headers);
    response.write(str);
    response.end();
}

function stat(fp)
{
    try {
        return fs.statSync(fp);
    } catch (err) {
    }
    return undefined;
}

http.createServer(function(request, response) {
    const u = url.parse(request.url);
    u.pathname = decodeURIComponent(u.pathname);
    const query = String(u.query).split("&");
    const cookies = parseCookies(request.headers.cookie);

    // Serve login page for GET requests to /__login
    if (request.method === 'GET' && u.pathname === '/__login') {
        loginHTML(response);
        return;
    }

    // Handle login POST
    if (request.method === 'POST' && u.pathname === '/__login') {
        let body = '';
        request.on('data', chunk => { body += chunk; });
        request.on('end', () => {
            const params = new URLSearchParams(body);
            const submittedPassword = params.get('password');
            if (submittedPassword === password) {
                response.writeHead(302, {
                    'Set-Cookie': `auth=${encodeURIComponent(submittedPassword)}; Path=/`,
                    'Location': '/'
                });
                response.end();
            } else {
                loginHTML(response);
            }
        });
        return;
    }

    // Check authentication via cookie
    if (password) {
        const authCookie = cookies.auth ? decodeURIComponent(cookies.auth) : null;
        if (authCookie !== password) {
            loginHTML(response);
            return;
        }
    }

    const filePath = path.join(args.dir, u.pathname);
    let statVal = stat(filePath);
    // console.log(filePath, statVal);
    if (!statVal) {
        response.writeHead(301, { Location: link("/") });
        response.end();
        return;
    }

    // console.log(u.query);

    if (statVal.isDirectory()) {
        const d = new Dir(args.dir, filePath);

        // Handle shuffle toggle
        if (query.indexOf("shuffle") !== -1) {
            const seed = Date.now();
            const setCookie = `shuffle=${seed}; Path=/`;
            dirHTML(u, response, d, query, {...cookies, shuffle: String(seed)}, setCookie);
            return;
        }
        if (query.indexOf("unshuffle") !== -1) {
            const setCookie = `shuffle=; Path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT`;
            dirHTML(u, response, d, query, {...cookies, shuffle: null}, setCookie);
            return;
        }

        dirHTML(u, response, d, query, cookies, null);
        return;
    }

    if (statVal.isFile() && isImage(filePath)) {
        const d = new Dir(args.dir, path.dirname(filePath));

        if (query.indexOf("data") !== -1) {
            fs.readFile(filePath, "binary", (err, file) => {
                if (err) {
                    response.writeHead(404, {"Content-Type": "text/plain"});
                    response.write(err + "\n");
                    response.end();
                    return;
                }

                response.writeHead(200);
                response.write(file, "binary");
                response.end();
            });
            return;
        }

        // Handle view toggle
        if (query.indexOf("view3") !== -1) {
            const setCookie = `tripleview=; Path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT`;
            imageHTML(response, u.pathname, d, {...cookies, tripleview: null}, setCookie);
            return;
        }
        if (query.indexOf("view1") !== -1) {
            const setCookie = `tripleview=0; Path=/`;
            imageHTML(response, u.pathname, d, {...cookies, tripleview: '0'}, setCookie);
            return;
        }

        // Handle shuffle toggle from image view
        if (query.indexOf("shuffle") !== -1) {
            const seed = Date.now();
            const setCookie = `shuffle=${seed}; Path=/`;
            imageHTML(response, u.pathname, d, {...cookies, shuffle: String(seed)}, setCookie);
            return;
        }
        if (query.indexOf("unshuffle") !== -1) {
            const setCookie = `shuffle=; Path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT`;
            imageHTML(response, u.pathname, d, {...cookies, shuffle: null}, setCookie);
            return;
        }

        if (query.indexOf("next") !== -1 || query.indexOf("prev") !== -1) {
            // Use shuffled order if shuffle is active
            const shuffleSeed = cookies.shuffle ? parseInt(cookies.shuffle, 10) : null;
            const images = shuffleSeed ? shuffleWithSeed(d.images, shuffleSeed) : d.images;

            let idx = images.indexOf(path.basename(u.pathname));
            if (idx === -1) {
                imageHTML(response, u.pathname, d, cookies, null);
                return;
            }
            if (query.indexOf("next") !== -1) {
                if (++idx === images.length) {
                    idx = 0;
                }
            } else {
                if (idx-- === 0) {
                    idx = images.length - 1;
                }
            }

            response.writeHead(301, { Location: `${link(path.join(d.relative, images[idx]))}` });
            response.end();
            return;
        }

        imageHTML(response, u.pathname, d, cookies, null);
        return;
    } else if (filePath.endsWith(".url")) {
        linksHTML(response, filePath);
        return;
    }

    response.writeHead(404);
    response.end();
    return;

    // console.log(statVal);

    // const filename = path.join(process.cwd(), uri);

    // fs.exists(filename, function(exists) {
    //     if(!exists) {
    //         response.writeHead(404, {"Content-Type": "text/plain"});
    //         response.write("404 Not Found\n");
    //         response.end();
    //         return;
    //     }

    //     if (fs.statSync(filename).isDirectory()) filename += '/index.html';

    //     fs.readFile(filename, "binary", function(err, file) {
    //         if(err) {
    //             response.writeHead(500, {"Content-Type": "text/plain"});
    //             response.write(err + "\n");
    //             response.end();
    //             return;
    //         }

    //         response.writeHead(200);
    //         response.write(file, "binary");
    //         response.end();
    //     });
    // });
}).listen(parseInt(args.port, 10));

console.log(args);
