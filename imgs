#!/usr/bin/env node

const args = require("minimist")(process.argv.slice(2));
const http = require("http");
const url = require("url");
const path = require("path");
const fs = require("fs");
const imageSize = require("image-size");
const Dir = require("./Dir");
const { isImage, isVideo, isMedia } = require("./media");
let password;

function getMimeType(filePath) {
    const ext = path.extname(filePath).toLowerCase();
    const mimeTypes = {
        '.jpg': 'image/jpeg',
        '.jpeg': 'image/jpeg',
        '.png': 'image/png',
        '.gif': 'image/gif',
        '.mp4': 'video/mp4',
        '.m4v': 'video/mp4',
        '.webm': 'video/webm',
        '.ogv': 'video/ogg',
        '.mov': 'video/quicktime',
        '.avi': 'video/x-msvideo',
        '.mkv': 'video/x-matroska',
        '.mpg': 'video/mpeg',
        '.mpeg': 'video/mpeg',
        '.wmv': 'video/x-ms-wmv',
        '.flv': 'video/x-flv',
        '.3gp': 'video/3gpp',
        '.rm': 'application/vnd.rn-realmedia',
        '.rmvb': 'application/vnd.rn-realmedia-vbr'
    };
    return mimeTypes[ext] || 'application/octet-stream';
}

function link(str, query)
{
    if (query) {
        if (str.indexOf("?") !== -1) {
            str += "&" + query;
        } else {
            str += "?" + query;
        }
    }
    return str;
}

// Seeded random number generator for consistent shuffling
function seededRandom(seed)
{
    return function() {
        seed = (seed * 1103515245 + 12345) & 0x7fffffff;
        return seed / 0x7fffffff;
    };
}

function shuffleWithSeed(array, seed)
{
    const result = [...array];
    const random = seededRandom(seed);
    for (let i = result.length - 1; i > 0; i--) {
        const j = Math.floor(random() * (i + 1));
        [result[i], result[j]] = [result[j], result[i]];
    }
    return result;
}

function parseCookies(cookieHeader)
{
    const cookies = {};
    if (!cookieHeader) return cookies;
    cookieHeader.split(';').forEach(cookie => {
        const parts = cookie.split('=');
        const name = parts[0].trim();
        const value = parts.slice(1).join('=').trim();
        if (name) cookies[name] = value;
    });
    return cookies;
}

function loginHTML(response, redirectTo)
{
    const redirect = redirectTo || '/';
    const html = `
<html>
  <head>
    <title>Login</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
body {
    font-family: sans-serif;
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    background: #f0f0f0;
}
form {
    background: white;
    padding: 2rem;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
}
input[type="text"] {
    font-size: 1rem;
    padding: 0.5rem;
    margin-right: 0.5rem;
    border: 1px solid #ccc;
    border-radius: 4px;
}
button {
    font-size: 1rem;
    padding: 0.5rem 1rem;
    background: #007bff;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}
button:hover {
    background: #0056b3;
}
    </style>
  </head>
  <body>
    <form id="loginForm">
      <input type="text" name="password" id="password" placeholder="Password" autofocus>
      <input type="hidden" id="redirect" value="${redirect}">
      <button type="submit">Login</button>
    </form>
    <script>
document.getElementById('loginForm').addEventListener('submit', function(e) {
    e.preventDefault();
    var pw = document.getElementById('password').value;
    var redirect = document.getElementById('redirect').value;
    sessionStorage.setItem('auth', pw);
    document.cookie = 'auth=' + encodeURIComponent(pw) + '; path=/';
    window.location.href = redirect;
});
document.getElementById('password').focus();
    </script>
  </body>
</html>`;
    response.writeHead(200, {"Content-Type": "text/html"});
    response.write(html);
    response.end();
}

const authCheckScript = `
<script>
(function() {
    var stored = sessionStorage.getItem('auth');
    if (!stored) {
        document.cookie = 'auth=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT';
        window.location.href = '/__login';
    }
})();
</script>`;


if (!args.dir) {
    console.error("No --dir");
    process.exit(1);
}

if (args.dir[args.dir.length - 1] !== "/") {
    args.dir += "/";
}
if (!args.port) {
    console.error("No --port");
    process.exit(1);
}

password = args.password ? String(args.password) : undefined;
const verbose = args.verbose || false;

function log(...logArgs) {
    if (verbose) {
        console.log('[verbose]', ...logArgs);
    }
}

if (verbose) {
    console.log('Verbose mode enabled');
    console.log('Serving directory:', args.dir);
}

// Watch source files for changes - exit so systemd can restart
const sourceFiles = [
    path.join(__dirname, 'imgs'),
    path.join(__dirname, 'Dir.js'),
    path.join(__dirname, 'media.js')
];

sourceFiles.forEach(file => {
    fs.watch(file, (event, filename) => {
        console.log(`Source file changed: ${file} (${event})`);
        process.exit(0);
    });
});

// Watch served directory recursively for changes (Linux Node 18.17+)
// On older Node.js, recursive option is silently ignored on Linux
// Since Dir reads fresh each request, there's no cache - this is just informational
if (parseInt(process.versions.node.split('.')[0], 10) >= 18) {
    try {
        fs.watch(args.dir, { recursive: true }, (event, filename) => {
            if (filename) {
                console.log(`Content changed: ${filename} (${event})`);
            }
        });
    } catch (err) {
        console.error('Could not set up recursive watch on served directory:', err.message);
    }
}

function linksHTML(response, filePath)
{
    fs.readFile(filePath, "utf-8", (err, data) => {
        if (err) {
            response.writeHead(404, {"Content-Type": "text/plain"});
            response.write(err + "\n");
            response.end();
            return;
        }

        const links = data.split("\n").filter(x => x.startsWith("http")).map(x => {
            return `    <p><a href="${link(x)}">${x}</a></p>`;
        }).join("\n");

        response.writeHead(200);
        const payload = `<html>
  <head>
${password ? authCheckScript : ''}
  </head>
  <body>
${links}
  </body>`;

        response.write(payload);
        response.end();
    });
}

function mediaTag(filepath, className, withControls)
{
    const src = link(filepath, 'data');
    if (isVideo(filepath)) {
        const controls = withControls ? ' controls muted' : '';
        return `<video class="${className}" src="${src}"${controls} muted playsinline preload="metadata"></video>`;
    }
    return `<img class="${className}" src="${src}"/>`;
}

function imageHTML(response, filepath, dir, cookies, setCookieHeader)
{
    const isVid = isVideo(filepath);
    const tripleView = cookies.tripleview !== '0';
    const toggleLink = tripleView ? link(filepath, 'view1') : link(filepath, 'view3');
    const toggleText = tripleView ? '1' : '3';

    const shuffleSeed = cookies.shuffle ? parseInt(cookies.shuffle, 10) : null;
    const shuffleLinks = shuffleSeed
        ? `<a href="${link(filepath, 'unshuffle')}">Unshuffle</a> | <a href="${link(filepath, 'shuffle')}">Reshuffle</a>`
        : `<a href="${link(filepath, 'shuffle')}">Shuffle</a>`;

    // Get prev/next images for triple view
    const images = shuffleSeed ? shuffleWithSeed(dir.images, shuffleSeed) : dir.images;
    const currentIdx = images.indexOf(path.basename(filepath));

    let prevImg = null, nextImg = null;
    if (currentIdx !== -1 && images.length > 1) {
        const prevIdx = currentIdx === 0 ? images.length - 1 : currentIdx - 1;
        const nextIdx = currentIdx === images.length - 1 ? 0 : currentIdx + 1;
        prevImg = path.join(dir.relative, images[prevIdx]);
        nextImg = path.join(dir.relative, images[nextIdx]);
    }

    const imgHeight = tripleView ? 'calc(33.33vh - 20px)' : 'calc(100vh - 60px)';

    let imagesHtml;
    if (tripleView && prevImg && nextImg) {
        imagesHtml = `
       <a href="${link(filepath, 'prev')}"><div class="imgbox">
         ${mediaTag(prevImg, 'center-fit', false)}
       </div></a>
       <div class="imgbox current">
         ${mediaTag(filepath, 'center-fit', isVid)}
       </div>
       <a href="${link(filepath, 'next')}"><div class="imgbox">
         ${mediaTag(nextImg, 'center-fit', false)}
       </div></a>`;
    } else {
        if (isVid) {
            imagesHtml = `
       <div class="imgbox">
         ${mediaTag(filepath, 'center-fit', true)}
       </div>`;
        } else {
            imagesHtml = `
       <a href="${link(filepath, 'next')}"><div class="imgbox">
         ${mediaTag(filepath, 'center-fit', false)}
       </div></a>`;
        }
    }

    const str = `
<html>
  <head title="${filepath}">
${password ? authCheckScript : ''}
    <style>
* {
    font-size: 25px;
    margin: 0;
    padding: 0;
}
html, body {
    height: 100%;
}
.imgbox {
    display: flex;
    justify-content: center;
    align-items: center;
    height: ${imgHeight};
}
.center-fit {
    width: 100%;
    height: 100%;
    object-fit: contain;
}
    </style>
  </head>
  <body>
     <p>
&nbsp;
     </p>
     <p>
       &nbsp;&nbsp;&nbsp;&nbsp;<a href="${link(filepath, 'prev')}">Previous</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="${link(filepath, 'next')}">Next</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="${link(path.dirname(filepath))}">Dir</a>&nbsp;&nbsp;&nbsp;&nbsp;<a href="${toggleLink}">${toggleText}</a>&nbsp;&nbsp;&nbsp;&nbsp;${shuffleLinks}
     </p>
${imagesHtml}
  </body>
</html>`;

    const headers = {"Content-Type": "text/html"};
    if (setCookieHeader) {
        headers["Set-Cookie"] = setCookieHeader;
    }
    response.writeHead(200, headers);
    response.write(str);
    response.end();
}

function dirHTML(url, response, dir, query, cookies, setCookieHeader)
{
    log('dirHTML called for:', dir.relative);
    const thumbSize = cookies.thumbsize ? parseInt(cookies.thumbsize, 10) : 100;
    let str = `
<html>
  <head title="${dir.relative}">
${password ? authCheckScript : ''}
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
* {
  box-sizing: border-box;
}

.controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px;
}

.controls a {
  font-size: 2rem;
  padding: 0.5rem 1rem;
  text-decoration: none;
}

.controls .middle {
  font-size: 1rem;
}

.controls .middle a {
  font-size: 1rem;
  padding: 0.25rem;
}

.grid {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  padding: 10px;
}

.grid a {
  display: block;
  flex: 0 0 auto;
}

.grid img {
  height: ${thumbSize}px;
  width: auto;
}

.grid .video-thumb {
  height: ${thumbSize}px;
  width: ${Math.floor(thumbSize * 1.5)}px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: space-between;
  background: #333;
  color: #fff;
  text-decoration: none;
  font-size: 12px;
  overflow: hidden;
  padding: 8px 0;
}

.grid .video-thumb .icon {
  font-size: ${Math.floor(thumbSize * 0.3)}px;
}

.grid .video-thumb .name {
  white-space: nowrap;
  overflow: hidden;
  width: 100%;
  padding: 0 4px;
  box-sizing: border-box;
}

.grid .video-thumb .name span {
  display: inline-block;
  padding-left: 100%;
  animation: marquee 8s linear infinite;
}

@keyframes marquee {
  0% { transform: translateX(0); }
  100% { transform: translateX(-100%); }
}
    </style>
  </head>
  <body>
`;
    if (dir.bookmarks) {
        str += `<p><a href="${link(path.join(dir.relative, 'bookmark.url'))}">Bookmarks</a></p>\n`;
    }

    let images = dir.images;
    log('dirHTML: dir.images has', dir.images.length, 'items');
    log('dirHTML: dir.relative =', dir.relative);
    const shuffleSeed = cookies.shuffle ? parseInt(cookies.shuffle, 10) : null;

    // Build controls bar: - on left, shuffle in middle, + on right
    let middleControls = [];
    if (!dir.root) {
        middleControls.push(`<a href="${link(path.dirname(dir.relative))}">parent dir</a>`);
    }
    if (shuffleSeed) {
        images = shuffleWithSeed(dir.images, shuffleSeed);
        if (images.length) {
            middleControls.push(`<a href="${link(dir.relative, 'unshuffle')}">Unshuffle</a> | <a href="${link(dir.relative, 'shuffle')}">Reshuffle</a>`);
        }
    } else {
        if (images.length) {
            middleControls.push(`<a href="${link(dir.relative, 'shuffle')}">Shuffle</a>`);
        }
    }
    str += `<div class="controls">
  <a href="${link(dir.relative, 'zoom-')}">-</a>
  <span class="middle">${middleControls.join(' &nbsp; ')}</span>
  <a href="${link(dir.relative, 'zoom+')}">+</a>
</div>\n`;

    dir.dirs.filter(d => d !== '..').forEach(dirpath => {
        str += `<p><a href="${link(path.join(dir.relative, dirpath))}">${dirpath}</a></p>
`;
    });
    log('dirHTML: rendering', images.length, 'media items');
    if (images.length) {
        str += `<div class="grid">\n`;
        images.forEach(img => {
            const mediaPath = path.join(dir.relative, img);
            log('dirHTML: adding media item:', mediaPath, 'isVideo:', isVideo(img));
            if (isVideo(img)) {
                str += `<a href="${link(mediaPath)}" class="video-thumb"><span class="icon">&#127910;</span><span class="name"><span>${img}</span></span></a>\n`;
            } else {
                str += `<a href="${link(mediaPath)}"><img src="${link(mediaPath, 'data')}"></a>\n`;
            }
        });
        str += `</div>\n`;
    }
    str += "</body>\n</html>";

    const headers = {"Content-Type": "text/html"};
    if (setCookieHeader) {
        headers["Set-Cookie"] = setCookieHeader;
    }
    response.writeHead(200, headers);
    response.write(str);
    response.end();
}

function stat(fp)
{
    try {
        return fs.statSync(fp);
    } catch (err) {
    }
    return undefined;
}

http.createServer(function(request, response) {
    const u = url.parse(request.url);
    u.pathname = decodeURIComponent(u.pathname);
    const query = String(u.query).split("&");
    const cookies = parseCookies(request.headers.cookie);

    log('Request:', request.method, u.pathname, 'query:', u.query);

    // Serve login page for GET requests to /__login
    if (request.method === 'GET' && u.pathname === '/__login') {
        loginHTML(response);
        return;
    }

    // Handle login POST
    if (request.method === 'POST' && u.pathname === '/__login') {
        let body = '';
        request.on('data', chunk => { body += chunk; });
        request.on('end', () => {
            const params = new URLSearchParams(body);
            const submittedPassword = params.get('password');
            if (submittedPassword === password) {
                response.writeHead(302, {
                    'Set-Cookie': `auth=${encodeURIComponent(submittedPassword)}; Path=/`,
                    'Location': '/'
                });
                response.end();
            } else {
                loginHTML(response);
            }
        });
        return;
    }

    // Check authentication via cookie
    if (password) {
        const authCookie = cookies.auth ? decodeURIComponent(cookies.auth) : null;
        if (authCookie !== password) {
            loginHTML(response, request.url);
            return;
        }
    }

    const filePath = path.join(args.dir, u.pathname);
    let statVal = stat(filePath);
    // console.log(filePath, statVal);
    if (!statVal) {
        response.writeHead(301, { Location: link("/") });
        response.end();
        return;
    }

    // console.log(u.query);

    if (statVal.isDirectory()) {
        const d = new Dir(args.dir, filePath, log);

        // Handle zoom
        const currentSize = cookies.thumbsize ? parseInt(cookies.thumbsize, 10) : 100;
        if (query.indexOf("zoom+") !== -1) {
            const newSize = Math.min(currentSize + 50, 500);
            const setCookie = `thumbsize=${newSize}; Path=/`;
            dirHTML(u, response, d, query, {...cookies, thumbsize: String(newSize)}, setCookie);
            return;
        }
        if (query.indexOf("zoom-") !== -1) {
            const newSize = Math.max(currentSize - 50, 50);
            const setCookie = `thumbsize=${newSize}; Path=/`;
            dirHTML(u, response, d, query, {...cookies, thumbsize: String(newSize)}, setCookie);
            return;
        }

        // Handle shuffle toggle
        if (query.indexOf("shuffle") !== -1) {
            const seed = Date.now();
            const setCookie = `shuffle=${seed}; Path=/`;
            dirHTML(u, response, d, query, {...cookies, shuffle: String(seed)}, setCookie);
            return;
        }
        if (query.indexOf("unshuffle") !== -1) {
            const setCookie = `shuffle=; Path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT`;
            dirHTML(u, response, d, query, {...cookies, shuffle: null}, setCookie);
            return;
        }

        dirHTML(u, response, d, query, cookies, null);
        return;
    }

    if (statVal.isFile() && isMedia(filePath)) {
        const d = new Dir(args.dir, path.dirname(filePath), log);

        if (query.indexOf("data") !== -1) {
            const mimeType = getMimeType(filePath);
            const fileSize = statVal.size;
            const range = request.headers.range;

            if (range && isVideo(filePath)) {
                // Handle Range request for video streaming
                const parts = range.replace(/bytes=/, '').split('-');
                const start = parseInt(parts[0], 10);
                const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;
                const chunkSize = end - start + 1;

                log('Range request:', start, '-', end, '/', fileSize);

                const stream = fs.createReadStream(filePath, { start, end });
                response.writeHead(206, {
                    'Content-Range': `bytes ${start}-${end}/${fileSize}`,
                    'Accept-Ranges': 'bytes',
                    'Content-Length': chunkSize,
                    'Content-Type': mimeType
                });
                stream.pipe(response);
            } else {
                // Regular file serving
                fs.readFile(filePath, "binary", (err, file) => {
                    if (err) {
                        response.writeHead(404, {"Content-Type": "text/plain"});
                        response.write(err + "\n");
                        response.end();
                        return;
                    }

                    response.writeHead(200, {
                        'Content-Type': mimeType,
                        'Content-Length': fileSize,
                        'Accept-Ranges': 'bytes'
                    });
                    response.write(file, "binary");
                    response.end();
                });
            }
            return;
        }

        // Handle view toggle
        if (query.indexOf("view3") !== -1) {
            const setCookie = `tripleview=; Path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT`;
            imageHTML(response, u.pathname, d, {...cookies, tripleview: null}, setCookie);
            return;
        }
        if (query.indexOf("view1") !== -1) {
            const setCookie = `tripleview=0; Path=/`;
            imageHTML(response, u.pathname, d, {...cookies, tripleview: '0'}, setCookie);
            return;
        }

        // Handle shuffle toggle from image view
        if (query.indexOf("shuffle") !== -1) {
            const seed = Date.now();
            const setCookie = `shuffle=${seed}; Path=/`;
            imageHTML(response, u.pathname, d, {...cookies, shuffle: String(seed)}, setCookie);
            return;
        }
        if (query.indexOf("unshuffle") !== -1) {
            const setCookie = `shuffle=; Path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT`;
            imageHTML(response, u.pathname, d, {...cookies, shuffle: null}, setCookie);
            return;
        }

        if (query.indexOf("next") !== -1 || query.indexOf("prev") !== -1) {
            // Use shuffled order if shuffle is active
            const shuffleSeed = cookies.shuffle ? parseInt(cookies.shuffle, 10) : null;
            const images = shuffleSeed ? shuffleWithSeed(d.images, shuffleSeed) : d.images;

            let idx = images.indexOf(path.basename(u.pathname));
            if (idx === -1) {
                imageHTML(response, u.pathname, d, cookies, null);
                return;
            }
            if (query.indexOf("next") !== -1) {
                if (++idx === images.length) {
                    idx = 0;
                }
            } else {
                if (idx-- === 0) {
                    idx = images.length - 1;
                }
            }

            response.writeHead(301, { Location: `${link(path.join(d.relative, images[idx]))}` });
            response.end();
            return;
        }

        imageHTML(response, u.pathname, d, cookies, null);
        return;
    } else if (filePath.endsWith(".url")) {
        linksHTML(response, filePath);
        return;
    }

    response.writeHead(404);
    response.end();
    return;

    // console.log(statVal);

    // const filename = path.join(process.cwd(), uri);

    // fs.exists(filename, function(exists) {
    //     if(!exists) {
    //         response.writeHead(404, {"Content-Type": "text/plain"});
    //         response.write("404 Not Found\n");
    //         response.end();
    //         return;
    //     }

    //     if (fs.statSync(filename).isDirectory()) filename += '/index.html';

    //     fs.readFile(filename, "binary", function(err, file) {
    //         if(err) {
    //             response.writeHead(500, {"Content-Type": "text/plain"});
    //             response.write(err + "\n");
    //             response.end();
    //             return;
    //         }

    //         response.writeHead(200);
    //         response.write(file, "binary");
    //         response.end();
    //     });
    // });
}).listen(parseInt(args.port, 10));

console.log(args);
